from datetime import datetime
from pathlib import Path

# ici on declare le le chemain du dossier ou va se trouver la backup des fichiers
bacukpFolder = Path("backup")
if not bacukpFolder.exists():
    bacukpFolder.mkdir()




choix = input("Voulez-vous chiffrer ou déchiffrer les fichiers ? (c/d) : ").strip().lower()

match choix:
    case "c":
        chiffrement = True
    case "d":
        chiffrement = False
    case _:
        print("Choix invalide. Veuillez entrer 'chiffrer' ou 'dechiffrer'.")
        exit(1)
        
#choix si le faire en dry ou pas         
# dry_run = input("Voulez-vous faire un dry run (ne pas modifier les fichiers) ? (o/n) : ").strip().lower() == "o"


dossier = input("Entrez le chemin du dossier contenant les fichiers à chiffrer : ").strip()
folder = Path(dossier)
key = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"]
decalage = int(input("Entrez le décalage pour le chiffrement : "))

if not decalage != int or decalage < 0:
    print("Le décalage doit être un entier positif et entier .")
    exit(1)
  

if not folder.is_dir():
    print("Le chemin spécifié n'a pas de dossier valide.")
    exit(1)


def chiffrer_data(data,key):
    for index , lettre  in enumerate(data): # l'index est la position de la lettre dans le texte et la lettre est la lettre elle même et le enumerate permet de parcourir le texte et d'avoir l'index et la lettre en même temps 
        # c quoi l'index ? c'est la position de la lettre dans le texte
        # quelle texte ? c'est le texte qui est dans le fichier que l'on veut chiffrer ou déchiffrer
        if lettre in key:
            position = key.index(lettre) # la position est la position de la lettre dans la clé
            new_position = (position + decalage) % len(key) # la formume de chiffrement est  la position de la lettre + le decalage modulo la longueur de la clé
            new_lettre = key[new_position]
            data[index] = new_lettre

def dechiffrer_data(data,key):
    for index , lettre  in enumerate(data):
        if lettre in key:
            position = key.index(lettre)
            new_position = (position - decalage) % len(key)
            new_lettre = key[new_position]
            data[index] = new_lettre 
 
# le fichier de backup doit etre dans le dossier backup 
def backup_file(file):
    backup_path = bacukpFolder / file.with_suffix('.bak').name
    if backup_path.exists():
        backup_path.unlink()
    file.rename(backup_path)
    return backup_path


for file in folder.glob('*.txt'):
    with open(file, 'r') as f:
        data = list(f.read())
    
    
    if chiffrement:
        backup_file(file)
        chiffrer_data(data, key)
    else:
        backup_file(file)
        dechiffrer_data(data, key)
    
    with open(file, 'w') as f:
        f.write(''.join(data))
   # file.unlink()
  

with open("file.logs", "a") as log_file:
    log_file.write(f"{'Chiffrement' if chiffrement else 'Dechiffrement'} fait sur les fichiers du dossier {dossier} avec un decalage de {decalage}. heure : {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
    


        


